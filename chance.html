<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Menú PNG AR — Feedback & Estado</title>

  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>

  <style>
    html,body { height:100%; margin:0; background:#000; font-family:system-ui, sans-serif; -webkit-font-smoothing:antialiased; }
    /* HUD simple en HTML para información rápida */
    #hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 9999;
      color: #00f0ff;
      background: rgba(4,12,20,0.6);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0,224,255,0.12);
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 24px rgba(0,224,255,0.06);
      min-width: 180px;
    }
    #hud b { color:#C6F8FF; }
    #toast {
      position: fixed;
      left: 50%;
      top: 12%;
      transform: translateX(-50%);
      z-index: 9999;
      display:none;
      background: linear-gradient(135deg, rgba(0,229,255,0.12), rgba(124,77,255,0.06));
      color: #E6FBFF;
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      font-weight:600;
      text-align:center;
      box-shadow: 0 12px 48px rgba(0,229,255,0.06);
    }
  </style>
</head>
<body>
  <!-- HUD HTML -->
  <div id="hud">
    <div>Vida: <b id="lifeLabel">100%</b></div>
    <div style="font-size:13px; margin-top:6px;">Última acción: <span id="lastAction">—</span></div>
  </div>

  <div id="toast"></div>

  <!-- Escena AR -->
  <a-scene embedded vr-mode-ui="enabled:false"
           arjs="sourceType: webcam; detectionMode: mono; trackingMethod: best; debugUIEnabled: false;">
    <!-- luces generales -->
    <a-entity light="type: ambient; intensity: 0.9"></a-entity>
    <a-entity light="type: directional; intensity: 1.2" position="1 1 0.5"></a-entity>

    <!-- cámara + cursor para toques (raycaster) -->
    <a-entity camera>
      <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable; interval: 50"></a-entity>
    </a-entity>

    <!-- Marcador Hiro con smoothing para estabilidad -->
    <a-marker preset="hiro" id="hiroMarker"
              smooth="true" smoothCount="8" smoothTolerance="0.01" smoothThreshold="5">

      <!-- base decorativa -->
      <a-entity position="0 0.05 0">
        <a-torus radius="1.05" radius-tubular="0.04" rotation="90 0 0"
                 material="color:#00e5ff; emissive:#00e5ff; metalness:0.6; roughness:0.35"></a-torus>
      </a-entity>

      <!-- Contenedor menú (flotando sobre el marcador) -->
      <a-entity id="menu3d" position="0 0.9 0" rotation="-90 0 0" scale="1 1 1" visible="false">

        <!-- Botón 1: Cambia carta (reduce vida 5%) -->
        <a-image id="btnChangeCard" src="1.png"
                 position="0 0.9 0" width="1.6" height="0.46"
                 class="clickable"
                 transparent="true"
                 material="shader: flat; opacity: 0.95">
        </a-image>

        <!-- Botón 2: Cambia probabilidades (reduce vida 3%) -->
        <a-image id="btnChangeProb" src="2.png"
                 position="0 0.0 0" width="1.6" height="0.46"
                 class="clickable"
                 transparent="true"
                 material="shader: flat; opacity: 0.95">
        </a-image>

        <!-- Botón 3: Elijo esta carta (no cambia vida) -->
        <a-image id="btnChoose" src="3OP.png"
                 position="0 -0.9 0" width="1.6" height="0.46"
                 class="clickable"
                 transparent="true"
                 material="shader: flat; opacity: 0.95">
        </a-image>

        <!-- Texto 3D que muestra el feedback corto (flota frente a los botones) -->
        <a-entity id="feedbackText" position="0 -1.5 0.02" rotation="0 0 0">
          <a-text id="feedback3d" value="" align="center" color="#BFF8FF" width="2.6" opacity="0"></a-text>
        </a-entity>

        <!-- Sistema de partículas simple para feedback -->
        <a-entity id="particlesRoot" position="0 0 0"></a-entity>

      </a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
  (function () {
    // Estado del jugador
    let life = 100;
    const lifeLabel = document.getElementById('lifeLabel');
    const lastAction = document.getElementById('lastAction');
    const toast = document.getElementById('toast');

    // Elementos A-Frame
    const menu3d = document.getElementById('menu3d');
    const marker = document.getElementById('hiroMarker');
    const btnChangeCard = document.getElementById('btnChangeCard');
    const btnChangeProb = document.getElementById('btnChangeProb');
    const btnChoose = document.getElementById('btnChoose');
    const feedback3d = document.getElementById('feedback3d');
    const particlesRoot = document.getElementById('particlesRoot');

    // Sonido (clic breve)
    let audioCtx;
    function playClick() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = 900;
        g.gain.value = 0.0001;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
        o.stop(audioCtx.currentTime + 0.12);
      } catch(e) { /* no audio */ }
    }

    // Actualiza HUD y texto 3D
    function updateLifeLabel() {
      life = Math.max(0, Math.min(100, Math.round(life*10)/10)); // redondeo 1 dec
      lifeLabel.textContent = life + '%';
    }

    // Mostrar toast HTML breve
    function showToast(msg, ms = 1500) {
      toast.textContent = msg;
      toast.style.display = 'block';
      toast.style.opacity = '1';
      toast.animate([{ transform: 'translateY(-8px)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 }], { duration: 220, easing: 'ease-out' });
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(()=> toast.style.display = 'none', 300);
      }, ms);
    }

    // Mostrar texto 3D en el menú (fade in/out)
    function show3DFeedback(text, color = '#BFF8FF', dur = 1400) {
      feedback3d.setAttribute('value', text);
      feedback3d.setAttribute('color', color);
      feedback3d.setAttribute('opacity', '1');
      feedback3d.setAttribute('scale', '0.5 0.5 0.5');
      // animaciones sencillas
      feedback3d.setAttribute('animation__scale', { property: 'scale', to: '1 1 1', dur: 220, easing: 'easeOutQuad' });
      feedback3d.setAttribute('animation__fade', { property: 'opacity', to: '0', delay: dur, dur: 360, easing: 'easeOutQuad' });
    }

    // Vibración corta si está disponible
    function vibrateShort() {
      if (navigator.vibrate) navigator.vibrate(40);
    }

    // Partículas sencillas (puntos que salen de la posición del botón)
    function spawnParticles(pos, color = '#66FFC9', amount = 12) {
      // limpia anteriores rápidamente
      particlesRoot.innerHTML = '';
      for (let i=0;i<amount;i++){
        const p = document.createElement('a-sphere');
        const angle = Math.random()*Math.PI*2;
        const dist = 0.18 + Math.random()*0.14;
        const dx = Math.cos(angle)*dist;
        const dy = (Math.random()*0.6 - 0.2);
        const dz = Math.sin(angle)*dist;
        p.setAttribute('position', `${pos.x + dx} ${pos.y + dy} ${pos.z + dz}`);
        p.setAttribute('radius', 0.02 + Math.random()*0.02);
        p.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: 1; shader: standard`);
        particlesRoot.appendChild(p);
        // animar con A-Frame animation
        const toY = parseFloat(p.getAttribute('position').split(' ')[1]) + (0.22 + Math.random()*0.12);
        p.setAttribute('animation__move', `property: position; to: ${pos.x + dx} ${toY} ${pos.z + dz}; dur: ${650 + Math.random()*400}; easing: easeOutCubic`);
        p.setAttribute('animation__fade', `property: material.opacity; to: 0; dur: ${650 + Math.random()*350}; delay: 150; easing: linear`);
        // eliminar después
        setTimeout(()=>{ if (p.parentNode) p.parentNode.removeChild(p); }, 1400);
      }
    }

    // Calcula y aplica efectos según acción
    function applyAction(action) {
      // action: 'keep' | 'prob' | 'change'
      let msg = '';
      if (action === 'keep') {
        msg = 'Has elegido mantener la carta — vida sin cambios.';
        // life unchanged
      } else if (action === 'prob') {
        life -= 3;
        msg = 'Aumentaste la probabilidad de lo bueno — vida -3%.';
      } else if (action === 'change') {
        life -= 5;
        msg = 'Has cambiado la carta — vida -5%.';
      }
      // clamp
      life = Math.max(0, Math.min(100, life));
      updateLifeLabel();
      lastAction.textContent = msg;
      showToast(msg, 1400);
      show3DFeedback(msg, action === 'keep' ? '#BFF8FF' : '#FFD8A8');
    }

    // Habilitar / inhabilitar visibilidad del menú según el marcador
    marker.addEventListener('markerFound', () => {
      menu3d.setAttribute('visible', 'true');
      showToast('Hiro detectado', 900);
    });
    marker.addEventListener('markerLost', () => {
      menu3d.setAttribute('visible', 'false');
    });

    // Helpers: obtener posición local del botón (para partículas)
    function getLocalPosition(el) {
      const p = el.object3D.position;
      // p es vector3 en espacio del marcador -> usar tal cual
      return { x: p.x, y: p.y, z: p.z };
    }

    // Eventos de los botones: usamos addEventListener por si el atributo onclick no siempre funciona en algunos móviles
    btnChangeCard.addEventListener('click', (ev) => {
      playClick(); vibrateShort();
      // efecto visual: pulso y glow
      btnChangeCard.emit('pressfx', {}, false);
      // spawn particles desde la posición del botón
      const pos = getLocalPosition(btnChangeCard);
      spawnParticles(pos, '#FF9A9A', 16);
      applyAction('change');
    });

    btnChangeProb.addEventListener('click', (ev) => {
      playClick(); vibrateShort();
      btnChangeProb.emit('pressfx', {}, false);
      const pos = getLocalPosition(btnChangeProb);
      spawnParticles(pos, '#FFD57A', 13);
      applyAction('prob');
    });

    btnChoose.addEventListener('click', (ev) => {
      playClick(); vibrateShort();
      btnChoose.emit('pressfx', {}, false);
      const pos = getLocalPosition(btnChoose);
      spawnParticles(pos, '#9AFFD8', 12);
      applyAction('keep');
    });

    // Añadimos animaciones "pressfx" en cada imagen para escalado y breve brillo
    function addPressFX(el) {
      // escala al presionar
      el.setAttribute('animation__press_in', 'property: scale; to: 0.95 0.95 0.95; dur: 90; startEvents: pressfx');
      el.setAttribute('animation__press_out', 'property: scale; to: 1 1 1; dur: 160; delay: 90; startEvents: pressfx');
      // brillo (emissive) fake via material color change
      el.setAttribute('animation__glow', 'property: material.emissiveIntensity; from: 0.0; to: 1.6; dur: 220; startEvents: pressfx; dir: alternate');
    }
    addPressFX(btnChangeCard);
    addPressFX(btnChangeProb);
    addPressFX(btnChoose);

    // Inicializa labels
    updateLifeLabel();
    lastAction.textContent = '—';

    // Hacer que el menú aparezca/oculte con suavidad
    menu3d.setAttribute('animation__show', 'property: visible; to: true; dur: 1'); // no-op pero sirve de referencia

    // Exponer algunas funciones para debugging en consola
    window._game = {
      getLife: () => life,
      setLife: (v) => { life = Math.max(0, Math.min(100, v)); updateLifeLabel(); }
    };
  })();
  </script>
</body>
</html>
